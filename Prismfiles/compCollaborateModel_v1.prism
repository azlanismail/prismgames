smg

//top level system 
system "MC"
"C1" || "C2"  //a set of resource collaborators
endsystem

//sub-system
system "C1"
M1
endsystem

//====================================
//inputs parameters

//USER-DEFINED PARAMETERS
const int MAXR = 2;  //UB for retry
const int MAXS = 5;  //UB for the number of collaborators
const double MAXUT = 0.7; //UB for the utility value
const int GOAL_TY = 1; //UB for collaborators
const int GOAL_TY_Q1 = 1; //performance violation
const int GOAL_TY_Q2 = 2; //availability
const int GOAL_TY_Q3 = 3; //safety
const int GOAL_TY_UT = 4; //utility-based
const int GOAL_TY_ML = 5; //multi

//PROBING PARAMETERS
const int RS_REQ_ID = 1; //initiator or requestor
const bool CURA = true; //current availability
const bool CURP = true; //current performance
const bool CURF = true; //current safety
const int DELAY = 3;  //current delay

//PROFILING PARAMETERS
const int RS0_ID = 0;
const double RS0_RU = 0.3;
const int RS0_RT = 3;

const int RS1_ID = 1;
const double RS1_RU = 0.2;
const int RS1_RT = 7;

const int RS2_ID = 2;
const double RS2_RU = 0.4;
const int RS2_RT = 2;

const int RS3_ID = 3;
const double RS3_RU = 0.15;
const int RS3_RT = 6;

const int RS4_ID = 4;
const double RS4_RU = 0.23;
const int RS4_RT = 5;

//=======================================
//CONTROLLING PARAMETERS
global a1: bool init CURA;     //states for the availability
global p1: bool init CURP;     //states for the performance violation
global f1: bool init CURF;     //states for the security/safety violation
//=======================================
module M1
t1:[0..2] init 1;      //to control the turn
s1:[0..MAXS] init 0; //states for the resource collaborator selection
r1:[0..MAXR] init 0;   //states for the retry
//a1: bool init CURA;     //states for the availability
//p1: bool init CURP;     //states for the performance violation
//f1: bool init CURF;     //states for the security/safety violation

// P1 moves:
// (turn) the turn is meant for P1
// (adapt) the collaborator is not itself
// (constraints) the goals/constraints are satisfied

[r1a!] (t1=0) & (RS_REQ_ID != RS0_ID) & (sat=true) & (s1=0) & (r1<=MAXR) -> (s1'= RS0_ID) & (r1'=r1+1) & (t1'=1);
[r1b!] (t1=0) & (RS_REQ_ID != RS1_ID) & (sat=true) & (s1=0) & (r1<=MAXR) -> (s1'= RS1_ID) & (r1'=r1+1) & (t1'=1);
[r1c!] (t1=0) & (RS_REQ_ID != RS2_ID) & (sat=true) & (s1=0) & (r1<=MAXR) -> (s1'= RS2_ID) & (r1'=r1+1) & (t1'=1);
[r1d!] (t1=0) & (RS_REQ_ID != RS3_ID) & (sat=true) & (s1=0) & (r1<=MAXR) -> (s1'= RS3_ID) & (r1'=r1+1) & (t1'=1);
[r1e!] (t1=0) & (RS_REQ_ID != RS4_ID) & (sat=true) & (s1=0) & (r1<=MAXR) -> (s1'= RS4_ID) & (r1'=r1+1) & (t1'=1);

// P2 moves:
// (turn) the turn is meant for P2
// (availability) change the behavior of availability state
// (performance) change the behavior of performance state
// (security) change the behavior of security state

[m1x?] (t1=1) -> 0.5:(a1'=false)&(t1'=2)&(s1'=0) + 0.5:(a1'=true)&(t1'=2);
[m1y?] (t1=1) -> 0.5:(p1'=false)&(t1'=2)&(s1'=0) + 0.5:(p1'=true)&(t1'=2);
[m1z?] (t1=1) -> 0.5:(f1'=false)&(t1'=2)&(s1'=0) + 0.5:(f1'=true)&(t1'=2);

//start the move
[st?] (t1=1) -> (t1'=2);

//terminate the process
//[tr1?] (t=1) & (r1>=MAXR) & (end=false) -> (end'=true);

//schedule the turn between subsystems
[] (t1=2) -> (t1'=0);
endmodule

//=============================================
//=============================================
//=============================================
system "C2"
M2
endsystem

//module M2=M1 [t1=t2, s1=s2, r1=r2, r1a=r2a, r1b=r2b, r1c=r2c, r1d=r2d, 
//       r1e=r2e, m1x=m2x, m1y=m2y, m1z=m2z, st1=st2, tr1=tr2, a1=a2, p1=p2, f1=f2] endmodule
//module M2=M1 [t1=t2, s1=s2, r1=r2, r1a=r2a, r1b=r2b, r1c=r2c, r1d=r2d, 
//              r1e=r2e, a1=a2, p1=p2, f1=f2] endmodule
module M2=M1 [t1=t2, s1=s2, r1=r2, r1a=r2a, r1b=r2b, r1c=r2c, r1d=r2d, 
              r1e=r2e] endmodule


//=================================
//QoS COMPUTATION FOR EACH METRIC

//to compute the overall response time for C1
formula ag1_rt =( s1 = RS0_ID ? RS0_RT + DELAY :
            	( s1 = RS1_ID ? RS1_RT + DELAY :
            	( s1 = RS2_ID ? RS2_RT + DELAY :
            	( s1 = RS3_ID ? RS3_RT + DELAY :
		( s1 = RS4_ID ? RS4_RT + DELAY : 0 )))));

//to compute the overall response time for C2
formula ag2_rt =( s2 = RS0_ID ? RS0_RT + DELAY :
            	( s2 = RS1_ID ? RS1_RT + DELAY :
            	( s2 = RS2_ID ? RS2_RT + DELAY :
            	( s2 = RS3_ID ? RS3_RT + DELAY :
		( s2 = RS4_ID ? RS4_RT + DELAY : 0 )))));

//to compute the overall response time for C1
formula ag1_ru =( s1 = RS0_ID ? RS0_RU :
            	( s1 = RS1_ID ? RS1_RU :
            	( s1 = RS2_ID ? RS2_RU :
            	( s1 = RS3_ID ? RS3_RU :
		( s1 = RS4_ID ? RS4_RU : 0 )))));

//to compute the overall response time for C2
formula ag2_ru =( s2 = RS0_ID ? RS0_RU :
            	( s2 = RS1_ID ? RS1_RU :
            	( s2 = RS2_ID ? RS2_RU :
            	( s2 = RS3_ID ? RS3_RU :
		( s2 = RS4_ID ? RS4_RU: 0 )))));

//=================================
//Computation for aggregation-based

//formula uv_all = uv_cs * WG_CS + uv_rt * WG_RT + uv_fr * WG_FR;
formula uv_all = 0.6;

//=================================
//QoS CONSTRAINTS CHECKING

//to check the satisfaction of performance
//false means violated, true means healthy
//formula sat_q1 = (t1=0 ? p1: (t2=0 ? p2: false));
formula sat_q1 = p1;

//to check the satisfaction of availability (associated to the failure too)
//false means unavailable, true means available
//formula sat_q2 = (t1=0? a1: (t2=0? a2: false));
formula sat_q2 = a1;

//to check the satisfaction of safety
//false means unsafe, true means safe
//formula sat_q3 = (t1=0? f1: (t2=0? f2: false));
formula sat_q3 = f1;

//to check the satisfaction of overall quality based on individual metric
//true if only each of them is true, otherwise false
formula sat_ml_all = ( (sat_q1=true) & (sat_q2=true) & (sat_q3=true) ? true:false);

//to check the satisfaction of overall quality based on utility
//true if only the utility
formula sat_ut_all = ( uv_all <= MAXUT ? true:false);

//to check the constraint satisfaction of the selected QoS attribute
//sat either get the reasoned boolean value, otherwise, it takes false
formula sat = ( GOAL_TY = GOAL_TY_Q1 ? sat_q1 :
              ( GOAL_TY = GOAL_TY_Q2 ? sat_q2 :
              ( GOAL_TY = GOAL_TY_Q3 ? sat_q3 :
              ( GOAL_TY = GOAL_TY_UT ? sat_ut_all :
              ( GOAL_TY = GOAL_TY_ML ? sat_ml_all : false)))));


//==============================================
//REWARD STRUCTURE

//time dimension: response time
rewards "c1_rt"
[r1a] true : ag1_rt;
[r1b] true : ag1_rt;
[r1c] true : ag1_rt;
[r1d] true : ag1_rt;
[r1e] true : ag1_rt;
endrewards

rewards "c2_rt"
[r1a] true : ag2_rt;
[r1b] true : ag2_rt;
[r1c] true : ag2_rt;
[r1d] true : ag2_rt;
[r1e] true : ag2_rt;
endrewards

//resource dimension: utilization
rewards "c1_ru"
[r1a] true : ag1_ru;
[r1b] true : ag1_ru;
[r1c] true : ag1_ru;
[r1d] true : ag1_ru;
[r1e] true : ag1_ru;
endrewards

rewards "c2_ru"
[r1a] true : ag2_ru;
[r1b] true : ag2_ru;
[r1c] true : ag2_ru;
[r1d] true : ag2_ru;
[r1e] true : ag2_ru;
endrewards

label "done1" = t1 = 2;
label "done2" = t2 = 2;
