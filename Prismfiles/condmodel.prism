smg
//=========Player definition=======
player p1
planner,[n0r0],[n0r1],[n0r2],[n1r0],[n1r1],[n1r2],[be],[end],[ter]
endplayer

player p2
environment,[n0e0],[n0e1],[n1e0],[n1e1]
endplayer

//=========User Requirements=======
const int A0_ID = 0;
const int A0_DUR = 10; //cost
const double A0_REL = 0.9; //reliability
const double A0_COST= 20; //max cost
const double A0_WG_COST = 0.3; //weight for cost
const double A0_WG_DUR = 0.3; //weight for duration
const double A0_WG_REL = 0.4; //weight for reliability

//=========Resource Profiles=======
const int MXN=2;
const int N0_MAX_SV=3;	//finite number of services
const int N0_MAX_EV=2;	//finite number of computing nodes
const int N1_MAX_SV=3;	//finite number of services
const int N1_MAX_EV=2;	//finite number of computing nodes

const int N0_RS0_ID = 0;
const int N0_RS0_COST = 33;	//cost
const bool N0_RS0_AVAIL = true;	//availability status
const int N0_RS0_DUR0 = 54;	//duration 0;
const int N0_RS0_DUR1 = 14;	//duration 1;
const double N0_RS0_REL0 = 0.5256993933989065;	//reliability 0;
const double N0_RS0_REL1 = 0.6083485935075041;	//reliability 1;

const int N0_RS1_ID = 1;
const int N0_RS1_COST = 47;	//cost
const bool N0_RS1_AVAIL = true;	//availability status
const int N0_RS1_DUR0 = 32;	//duration 0;
const int N0_RS1_DUR1 = 95;	//duration 1;
const double N0_RS1_REL0 = 0.18565093697988155;	//reliability 0;
const double N0_RS1_REL1 = 0.10003138022550084;	//reliability 1;

const int N0_RS2_ID = 2;
const int N0_RS2_COST = 18;	//cost
const bool N0_RS2_AVAIL = true;	//availability status
const int N0_RS2_DUR0 = 99;	//duration 0;
const int N0_RS2_DUR1 = 69;	//duration 1;
const double N0_RS2_REL0 = 0.1390514505490924;	//reliability 0;
const double N0_RS2_REL1 = 0.9910446973788464;	//reliability 1;

const int N1_RS0_ID = 0;
const int N1_RS0_COST = 54;	//cost
const bool N1_RS0_AVAIL = true;	//availability status
const int N1_RS0_DUR0 = 53;	//duration 0;
const int N1_RS0_DUR1 = 99;	//duration 1;
const double N1_RS0_REL0 = 0.8512087054947332;	//reliability 0;
const double N1_RS0_REL1 = 0.42243209991117214;	//reliability 1;

const int N1_RS1_ID = 1;
const int N1_RS1_COST = 56;	//cost
const bool N1_RS1_AVAIL = true;	//availability status
const int N1_RS1_DUR0 = 38;	//duration 0;
const int N1_RS1_DUR1 = 6;	//duration 1;
const double N1_RS1_REL0 = 0.49672769727838395;	//reliability 0;
const double N1_RS1_REL1 = 0.35612566710127;	//reliability 1;

const int N1_RS2_ID = 2;
const int N1_RS2_COST = 40;	//cost
const bool N1_RS2_AVAIL = true;	//availability status
const int N1_RS2_DUR0 = 52;	//duration 0;
const int N1_RS2_DUR1 = 68;	//duration 1;
const double N1_RS2_REL0 = 0.6628532863016433;	//reliability 0;
const double N1_RS2_REL1 = 0.09981857724326815;	//reliability 1;


//=========Global Parameters=======
const int TE=0;	//plater 2 state
const int TP=1;	//player 1 state
const int TS=2;	//coordinator state
global t:[TE..TS] init TS;	//to control the turn
global end : bool init false;	//(absorbing state)
global n:[0..MXN] init 0;  //to control the sequence

//=========Module for Player 1=======
module planner
n0:[-1..N0_MAX_SV-1] init -1;
n1:[-1..N1_MAX_SV-1] init -1;
//P1's coordinator :
//for conditional pattern
[be] (t=TS) & (n < MXN) -> (n'=0) & (t'=TP);
[be] (t=TS) & (n < MXN) -> (n'=1) & (t'=TP);
[end] (t=TS) & (n >= MXN) & (end=false) -> (end'=true); //for ending the selection
[ter] (t=TS) & (n >= MXN) & (end=true) -> true;	//for absorbing state
//P1 moves :
[n0r0] (t=TP) & (n=0) & (a0_n0_rs0_sat_all=true) -> (n0'=0) & (t'=TE);
[n0r1] (t=TP) & (n=0) & (a0_n0_rs1_sat_all=true) -> (n0'=1) & (t'=TE);
[n0r2] (t=TP) & (n=0) & (a0_n0_rs2_sat_all=true) -> (n0'=2) & (t'=TE);
[n1r0] (t=TP) & (n=1) & (a0_n1_rs0_sat_all=true) -> (n1'=0) & (t'=TE);
[n1r1] (t=TP) & (n=1) & (a0_n1_rs1_sat_all=true) -> (n1'=1) & (t'=TE);
[n1r2] (t=TP) & (n=1) & (a0_n1_rs2_sat_all=true) -> (n1'=2) & (t'=TE);
endmodule

//=========Module for Player 2=======
module environment
n0ev:[-1..N0_MAX_EV] init -1;
n1ev:[-1..N1_MAX_EV] init -1;
//P2 moves for conditional pattern:
[n0e0] (t=TE) & (n=0) -> n0ev0_rel:(n0ev'=0) & (t'=TS) & (n'=MXN) + 1-n0ev0_rel:(n0ev'=-1) & (t'=TS) & (n'=MXN);
[n0e1] (t=TE) & (n=0) -> n0ev1_rel:(n0ev'=1) & (t'=TS) & (n'=MXN) + 1-n0ev1_rel:(n0ev'=-1) & (t'=TS) & (n'=MXN);
[n1e0] (t=TE) & (n=1) -> n1ev0_rel:(n1ev'=0) & (t'=TS) & (n'=MXN) + 1-n1ev0_rel:(n1ev'=-1) & (t'=TS) & (n'=MXN);
[n1e1] (t=TE) & (n=1) -> n1ev1_rel:(n1ev'=1) & (t'=TS) & (n'=MXN) + 1-n1ev1_rel:(n1ev'=-1) & (t'=TS) & (n'=MXN);
endmodule

//=========Assign reliability values=======
formula n0ev0_rel = ( n0 = 0 ? N0_RS0_REL0 : ( n0 = 1 ? N0_RS1_REL0 : ( n0 = 2 ? N0_RS2_REL0 :0.0)));
formula n0ev1_rel = ( n0 = 0 ? N0_RS0_REL1 : ( n0 = 1 ? N0_RS1_REL1 : ( n0 = 2 ? N0_RS2_REL1 :0.0)));

formula n1ev0_rel = ( n1 = 0 ? N1_RS0_REL0 : ( n1 = 1 ? N1_RS1_REL0 : ( n1 = 2 ? N1_RS2_REL0 :0.0)));
formula n1ev1_rel = ( n1 = 0 ? N1_RS0_REL1 : ( n1 = 1 ? N1_RS1_REL1 : ( n1 = 2 ? N1_RS2_REL1 :0.0)));


//=========QoS Constraints Checking=======
//=====Application 0, Node0 and RS0
formula a0_n0_rs0_sat_dur0 = ( (A0_DUR <= N0_RS0_DUR0) ? true:false);
formula a0_n0_rs0_sat_dur1 = ( (A0_DUR <= N0_RS0_DUR1) ? true:false);
formula a0_n0_rs0_sat_rel0 = ( (A0_DUR <= N0_RS0_REL0) ? true:false);
formula a0_n0_rs0_sat_rel1 = ( (A0_DUR <= N0_RS0_REL1) ? true:false);
formula a0_n0_rs0_sat_cost = ( (A0_COST <= N0_RS0_COST) ? true:false);
formula a0_n0_rs0_sat_avail = N0_RS0_AVAIL;
formula a0_n0_rs0_sat_all = a0_n0_rs0_sat_avail;

//=====Application 0, Node0 and RS1
formula a0_n0_rs1_sat_dur0 = ( (A0_DUR <= N0_RS1_DUR0) ? true:false);
formula a0_n0_rs1_sat_dur1 = ( (A0_DUR <= N0_RS1_DUR1) ? true:false);
formula a0_n0_rs1_sat_rel0 = ( (A0_DUR <= N0_RS1_REL0) ? true:false);
formula a0_n0_rs1_sat_rel1 = ( (A0_DUR <= N0_RS1_REL1) ? true:false);
formula a0_n0_rs1_sat_cost = ( (A0_COST <= N0_RS1_COST) ? true:false);
formula a0_n0_rs1_sat_avail = N0_RS1_AVAIL;
formula a0_n0_rs1_sat_all = a0_n0_rs1_sat_avail;

//=====Application 0, Node0 and RS2
formula a0_n0_rs2_sat_dur0 = ( (A0_DUR <= N0_RS2_DUR0) ? true:false);
formula a0_n0_rs2_sat_dur1 = ( (A0_DUR <= N0_RS2_DUR1) ? true:false);
formula a0_n0_rs2_sat_rel0 = ( (A0_DUR <= N0_RS2_REL0) ? true:false);
formula a0_n0_rs2_sat_rel1 = ( (A0_DUR <= N0_RS2_REL1) ? true:false);
formula a0_n0_rs2_sat_cost = ( (A0_COST <= N0_RS2_COST) ? true:false);
formula a0_n0_rs2_sat_avail = N0_RS2_AVAIL;
formula a0_n0_rs2_sat_all = a0_n0_rs2_sat_avail;

//=====Application 0, Node1 and RS0
formula a0_n1_rs0_sat_dur0 = ( (A0_DUR <= N1_RS0_DUR0) ? true:false);
formula a0_n1_rs0_sat_dur1 = ( (A0_DUR <= N1_RS0_DUR1) ? true:false);
formula a0_n1_rs0_sat_rel0 = ( (A0_DUR <= N1_RS0_REL0) ? true:false);
formula a0_n1_rs0_sat_rel1 = ( (A0_DUR <= N1_RS0_REL1) ? true:false);
formula a0_n1_rs0_sat_cost = ( (A0_COST <= N1_RS0_COST) ? true:false);
formula a0_n1_rs0_sat_avail = N1_RS0_AVAIL;
formula a0_n1_rs0_sat_all = a0_n1_rs0_sat_avail;

//=====Application 0, Node1 and RS1
formula a0_n1_rs1_sat_dur0 = ( (A0_DUR <= N1_RS1_DUR0) ? true:false);
formula a0_n1_rs1_sat_dur1 = ( (A0_DUR <= N1_RS1_DUR1) ? true:false);
formula a0_n1_rs1_sat_rel0 = ( (A0_DUR <= N1_RS1_REL0) ? true:false);
formula a0_n1_rs1_sat_rel1 = ( (A0_DUR <= N1_RS1_REL1) ? true:false);
formula a0_n1_rs1_sat_cost = ( (A0_COST <= N1_RS1_COST) ? true:false);
formula a0_n1_rs1_sat_avail = N1_RS1_AVAIL;
formula a0_n1_rs1_sat_all = a0_n1_rs1_sat_avail;

//=====Application 0, Node1 and RS2
formula a0_n1_rs2_sat_dur0 = ( (A0_DUR <= N1_RS2_DUR0) ? true:false);
formula a0_n1_rs2_sat_dur1 = ( (A0_DUR <= N1_RS2_DUR1) ? true:false);
formula a0_n1_rs2_sat_rel0 = ( (A0_DUR <= N1_RS2_REL0) ? true:false);
formula a0_n1_rs2_sat_rel1 = ( (A0_DUR <= N1_RS2_REL1) ? true:false);
formula a0_n1_rs2_sat_cost = ( (A0_COST <= N1_RS2_COST) ? true:false);
formula a0_n1_rs2_sat_avail = N1_RS2_AVAIL;
formula a0_n1_rs2_sat_all = a0_n1_rs2_sat_avail;


//=========Utility-based Decision Making=======
//get the cost of selected node..
formula n0_rs_cost =( n0 = 0 ? N0_RS0_COST :( n0 = 1 ? N0_RS1_COST :( n0 = 2 ? N0_RS2_COST :0.0)));
//Computing the utility value..
formula n0_mx_cost = max(N0_RS0_COST,N0_RS1_COST,N0_RS2_COST);
formula n0_mn_cost = min(N0_RS0_COST,N0_RS1_COST,N0_RS2_COST);
formula n0_uv_cost = (n0_mx_cost - n0_rs_cost) / (n0_mx_cost - n0_mn_cost);

//get the duration of selected node..
formula n0_rs_dur0=( (n0 = 0 & n0ev = 0) ? N0_RS0_DUR0 :( (n0 = 1 & n0ev = 0) ? N0_RS1_DUR0 :( (n0 = 2 & n0ev = 0) ? N0_RS2_DUR0 :0.0)));
//Computing the utility value..
formula n0_mx_dur0 = max(N0_RS0_DUR0,N0_RS1_DUR0,N0_RS2_DUR0);
formula n0_mn_dur0 = min(N0_RS0_DUR0,N0_RS1_DUR0,N0_RS2_DUR0);
formula n0_uv_dur0 = (n0_mx_dur0 - n0_rs_dur0) / (n0_mx_dur0 - n0_mn_dur0);

formula n0_rs_dur1=( (n0 = 0 & n0ev = 1) ? N0_RS0_DUR1 :( (n0 = 1 & n0ev = 1) ? N0_RS1_DUR1 :( (n0 = 2 & n0ev = 1) ? N0_RS2_DUR1 :0.0)));
//Computing the utility value..
formula n0_mx_dur1 = max(N0_RS0_DUR1,N0_RS1_DUR1,N0_RS2_DUR1);
formula n0_mn_dur1 = min(N0_RS0_DUR1,N0_RS1_DUR1,N0_RS2_DUR1);
formula n0_uv_dur1 = (n0_mx_dur1 - n0_rs_dur1) / (n0_mx_dur1 - n0_mn_dur1);

//get the reliability of selected node..
formula n0_rs_rel0=( (n0 = 0 & n0ev = 0) ? N0_RS0_REL0 :( (n0 = 1 & n0ev = 0) ? N0_RS1_REL0 :( (n0 = 2 & n0ev = 0) ? N0_RS2_REL0 :0.0)));
//Computing the utility value..
formula n0_mx_rel0 = max(N0_RS0_REL0,N0_RS1_REL0,N0_RS2_REL0);
formula n0_mn_rel0 = min(N0_RS0_REL0,N0_RS1_REL0,N0_RS2_REL0);
formula n0_uv_rel0 = (n0_mx_rel0 - n0_rs_rel0) / (n0_mx_rel0 - n0_mn_rel0);

formula n0_rs_rel1=( (n0 = 0 & n0ev = 1) ? N0_RS0_REL1 :( (n0 = 1 & n0ev = 1) ? N0_RS1_REL1 :( (n0 = 2 & n0ev = 1) ? N0_RS2_REL1 :0.0)));
//Computing the utility value..
formula n0_mx_rel1 = max(N0_RS0_REL1,N0_RS1_REL1,N0_RS2_REL1);
formula n0_mn_rel1 = min(N0_RS0_REL1,N0_RS1_REL1,N0_RS2_REL1);
formula n0_uv_rel1 = (n0_mx_rel1 - n0_rs_rel1) / (n0_mx_rel1 - n0_mn_rel1);


//Preventing from non-evaluated problem..
formula n0_ut_cost = (n0_uv_cost > 0.0 ? n0_uv_cost: 0.0);
formula n0_ut_dur0 = (n0_uv_dur0 > 0.0 ? n0_uv_dur0: 0.0);
formula n0_ut_dur1 = (n0_uv_dur1 > 0.0 ? n0_uv_dur1: 0.0);
formula n0_ut_rel0 = (n0_uv_rel0 > 0.0 ? n0_uv_rel0: 0.0);
formula n0_ut_rel1 = (n0_uv_rel1 > 0.0 ? n0_uv_rel1: 0.0);

//Compute the overall utility value..
formula n0_ut_all = (n0ev=0 ? (n0_ut_cost * A0_WG_COST + n0_ut_dur0 * A0_WG_DUR + n0_ut_rel0 * A0_WG_REL):(n0ev=1 ? (n0_ut_cost * A0_WG_COST + n0_ut_dur1 * A0_WG_DUR + n0_ut_rel1 * A0_WG_REL):0.0));

//get the cost of selected node..
formula n1_rs_cost =( n1 = 0 ? N1_RS0_COST :( n1 = 1 ? N1_RS1_COST :( n1 = 2 ? N1_RS2_COST :0.0)));
//Computing the utility value..
formula n1_mx_cost = max(N1_RS0_COST,N1_RS1_COST,N1_RS2_COST);
formula n1_mn_cost = min(N1_RS0_COST,N1_RS1_COST,N1_RS2_COST);
formula n1_uv_cost = (n1_mx_cost - n1_rs_cost) / (n1_mx_cost - n1_mn_cost);

//get the duration of selected node..
formula n1_rs_dur0=( (n1 = 0 & n1ev = 0) ? N1_RS0_DUR0 :( (n1 = 1 & n1ev = 0) ? N1_RS1_DUR0 :( (n1 = 2 & n1ev = 0) ? N1_RS2_DUR0 :0.0)));
//Computing the utility value..
formula n1_mx_dur0 = max(N1_RS0_DUR0,N1_RS1_DUR0,N1_RS2_DUR0);
formula n1_mn_dur0 = min(N1_RS0_DUR0,N1_RS1_DUR0,N1_RS2_DUR0);
formula n1_uv_dur0 = (n1_mx_dur0 - n1_rs_dur0) / (n1_mx_dur0 - n1_mn_dur0);

formula n1_rs_dur1=( (n1 = 0 & n1ev = 1) ? N1_RS0_DUR1 :( (n1 = 1 & n1ev = 1) ? N1_RS1_DUR1 :( (n1 = 2 & n1ev = 1) ? N1_RS2_DUR1 :0.0)));
//Computing the utility value..
formula n1_mx_dur1 = max(N1_RS0_DUR1,N1_RS1_DUR1,N1_RS2_DUR1);
formula n1_mn_dur1 = min(N1_RS0_DUR1,N1_RS1_DUR1,N1_RS2_DUR1);
formula n1_uv_dur1 = (n1_mx_dur1 - n1_rs_dur1) / (n1_mx_dur1 - n1_mn_dur1);

//get the reliability of selected node..
formula n1_rs_rel0=( (n1 = 0 & n1ev = 0) ? N1_RS0_REL0 :( (n1 = 1 & n1ev = 0) ? N1_RS1_REL0 :( (n1 = 2 & n1ev = 0) ? N1_RS2_REL0 :0.0)));
//Computing the utility value..
formula n1_mx_rel0 = max(N1_RS0_REL0,N1_RS1_REL0,N1_RS2_REL0);
formula n1_mn_rel0 = min(N1_RS0_REL0,N1_RS1_REL0,N1_RS2_REL0);
formula n1_uv_rel0 = (n1_mx_rel0 - n1_rs_rel0) / (n1_mx_rel0 - n1_mn_rel0);

formula n1_rs_rel1=( (n1 = 0 & n1ev = 1) ? N1_RS0_REL1 :( (n1 = 1 & n1ev = 1) ? N1_RS1_REL1 :( (n1 = 2 & n1ev = 1) ? N1_RS2_REL1 :0.0)));
//Computing the utility value..
formula n1_mx_rel1 = max(N1_RS0_REL1,N1_RS1_REL1,N1_RS2_REL1);
formula n1_mn_rel1 = min(N1_RS0_REL1,N1_RS1_REL1,N1_RS2_REL1);
formula n1_uv_rel1 = (n1_mx_rel1 - n1_rs_rel1) / (n1_mx_rel1 - n1_mn_rel1);


//Preventing from non-evaluated problem..
formula n1_ut_cost = (n1_uv_cost > 0.0 ? n1_uv_cost: 0.0);
formula n1_ut_dur0 = (n1_uv_dur0 > 0.0 ? n1_uv_dur0: 0.0);
formula n1_ut_dur1 = (n1_uv_dur1 > 0.0 ? n1_uv_dur1: 0.0);
formula n1_ut_rel0 = (n1_uv_rel0 > 0.0 ? n1_uv_rel0: 0.0);
formula n1_ut_rel1 = (n1_uv_rel1 > 0.0 ? n1_uv_rel1: 0.0);

//Compute the overall utility value..
formula n1_ut_all = (n1ev=0 ? (n1_ut_cost * A0_WG_COST + n1_ut_dur0 * A0_WG_DUR + n1_ut_rel0 * A0_WG_REL):(n1ev=1 ? (n1_ut_cost * A0_WG_COST + n1_ut_dur1 * A0_WG_DUR + n1_ut_rel1 * A0_WG_REL):0.0));

//=========Reward Structure=======
rewards "cost"
[end] true: n0_rs_cost;
[end] true: n1_rs_cost;
endrewards
rewards "time"
[end] true: n0_rs_dur0;
[end] true: n0_rs_dur1;
[end] true: n1_rs_dur0;
[end] true: n1_rs_dur1;
endrewards
rewards "reliability"
[end] true: n0_rs_rel0;
[end] true: n0_rs_rel1;
[end] true: n1_rs_rel0;
[end] true: n1_rs_rel1;
endrewards
rewards "utility"
[end] true: n0_ut_all;
[end] true: n1_ut_all;
endrewards

//=========Labels=======
label "done" = (end=true);
